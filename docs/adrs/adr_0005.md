---
title: "URN Scheme for Memory Addressing"
description: "Adopts subcog://{domain}/{namespace}/{id} URN scheme for unique, human-readable memory identifiers compatible with MCP resources."
type: adr
category: architecture
tags:
  - urn
  - addressing
  - identifiers
  - mcp
  - namespacing
status: accepted
created: 2025-12-28
updated: 2026-01-04
author: Claude (Architect)
project: subcog
technologies:
  - mcp
  - uri
audience:
  - developers
  - architects
confidence: high
completeness: complete
---

# ADR-0005: URN Scheme for Memory Addressing

## Status

Accepted

## Context

### Problem Statement

Subcog is a persistent memory system that stores contextual information across multiple scopes: project-specific memories tied to a git repository, user-specific memories that follow a developer across projects, and organization-wide memories shared across teams. Each memory unit requires a unique, stable identifier that can be referenced consistently across different interfaces, storage backends, and time periods.

### Why This Decision Was Needed

The original Python implementation (git-notes-memory) used simple UUIDs as memory identifiers. While UUIDs guarantee uniqueness, they provide no semantic information about the memory's scope, location, or relationships. When integrating with the Model Context Protocol (MCP), which expects resource URIs for tool interactions, a more structured addressing scheme became necessary.

### System Requirements

The addressing scheme must satisfy these requirements:

1. **Global Uniqueness**: No two memories, regardless of scope or storage backend, should ever collide in their identifiers. This is critical because memories may be migrated between backends (SQLite to PostgreSQL), exported/imported between systems, or referenced in external documentation.

2. **Scope Encoding**: The identifier must encode which domain (project, user, org) owns the memory. This enables permission checks, storage routing, and UI organization without additional lookups.

3. **Namespace Encoding**: Within a domain, memories are categorized into namespaces (decisions, learnings, patterns, blockers). The identifier should reflect this categorization to enable efficient filtering and logical grouping.

4. **Human Readability**: Unlike opaque UUIDs, identifiers should be partially readable so developers can understand what they reference without database lookups. This aids debugging, logging, and documentation.

5. **MCP Compatibility**: The Model Context Protocol uses URIs for resource identification. The addressing scheme must be a valid URI that MCP clients can parse and resolve.

6. **Stability**: Once assigned, an identifier must never change, even if the memory's content is updated. This ensures external references (in code comments, documentation, or other memories) remain valid.

7. **Parseability**: Standard URI parsing libraries should be able to decompose the identifier into its constituent parts (scheme, domain, namespace, id) without custom parsing logic.

### Constraints

- **Backward Compatibility**: Existing memories in the system have short-form IDs (12-character hex strings derived from content hashes). The new scheme must accommodate these.
- **Storage Efficiency**: While URNs are longer than raw IDs, the scheme should not impose unreasonable storage overhead.
- **Cross-Platform**: The scheme must work identically across macOS, Linux, and Windows, avoiding platform-specific path conventions.
- **ASCII-Safe**: To avoid encoding issues in logs, URLs, and JSON, the scheme should primarily use ASCII characters.

### Prior Art Considered

| Scheme | Example | Pros | Cons |
|--------|---------|------|------|
| UUID only | `550e8400-e29b-41d4-a716-446655440000` | Simple, universally unique | No semantic info, not a URI |
| Path-based | `/project/my-app/decisions/abc123` | Readable, hierarchical | Not a URI, ambiguous root |
| URL-based | `https://subcog.io/mem/abc123` | Standard URI, resolvable | Requires network, external dependency |
| URN-based | `urn:subcog:project:decisions:abc123` | Standard URN, no network | Less readable, non-standard parsing |
| Custom URI | `subcog://project/decisions/abc123` | Custom scheme, hierarchical | Requires custom handler registration |

## Decision Drivers

### Primary Drivers

1. **MCP Resource Model Alignment**: MCP resources are identified by URIs. Using a URI scheme for memory addressing allows direct mapping between Subcog memories and MCP resources. When an AI assistant requests `subcog://project:my-app/patterns/abc1234:0`, the MCP server can resolve this directly without translation layers.

2. **Hierarchical Organization**: The three-tier hierarchy (domain/namespace/id) maps naturally to Subcog's storage architecture. Domains correspond to storage backends (project uses SQLite in `.subcog/`, user uses SQLite in `~/.subcog/`, org uses PostgreSQL). Namespaces correspond to logical categories within each backend. IDs are the atomic memory units.

3. **Debuggability**: When a memory appears in logs, stack traces, or error messages, the URN immediately conveys its scope and category. Seeing `subcog://project:my-app/decisions/abc1234:0` in a log tells the developer exactly where to look, unlike a bare UUID.

4. **Future Extensibility**: The URN scheme can accommodate future extensions:
   - Additional domains (e.g., `subcog://team:backend/patterns/...`)
   - Metadata parameters (e.g., `subcog://project/decisions/abc?format=json`)
   - Fragment identifiers (e.g., `subcog://project/decisions/abc#section-3`)

### Secondary Drivers

5. **URI Standard Compliance**: By using the `://` authority separator and `/` path separators, the scheme follows RFC 3986 generic syntax. This means standard URI libraries in Rust (`url` crate), JavaScript, Python, and other languages can parse these identifiers correctly.

6. **Copy-Paste Friendliness**: URNs can be copied from logs, pasted into documentation, and clicked in terminals that support URI handlers. The scheme prefix `subcog://` makes it clear this is a Subcog reference.

7. **Collision Avoidance**: The hierarchical structure ensures that even if two different projects have memories with the same namespace and ID suffix, they are distinguished by their domain portion.

## Considered Options

### Option 1: Plain UUIDs (Rejected)

**Description**: Continue using UUID v4 identifiers (e.g., `550e8400-e29b-41d4-a716-446655440000`) as the sole identifier for memories.

**Technical Details**:
- UUID v4 provides 122 bits of randomness
- Collision probability is negligible (1 in 2^122)
- 36 characters in canonical form (32 hex + 4 hyphens)

**Pros**:
- Universally understood format
- No coordination required for generation
- Fixed length simplifies storage allocation
- Supported by all databases natively

**Cons**:
- No semantic information encoded
- Cannot determine scope without database lookup
- Not a valid URI for MCP resources
- Difficult to discuss verbally or in documentation
- No hierarchical structure for filtering

**Why Rejected**: Does not satisfy MCP compatibility requirement or human readability goals. Would require a separate mapping layer between MCP resources and internal IDs.

### Option 2: Path-Based Identifiers (Rejected)

**Description**: Use filesystem-style paths like `/project/my-app/decisions/abc123` as identifiers.

**Technical Details**:
- Hierarchical structure using `/` separators
- Domain encoded as first path segment
- Namespace as second segment
- ID as final segment

**Pros**:
- Very human-readable
- Natural hierarchy
- Easy to implement with string splitting

**Cons**:
- Not a valid URI (no scheme)
- Ambiguous interpretation (absolute vs. relative)
- Platform-specific path separator issues on Windows
- No standard parsing library support

**Why Rejected**: Fails URI standard compliance and cross-platform requirements. Would require custom parsing logic that varies by platform.

### Option 3: HTTPS URLs (Rejected)

**Description**: Use resolvable HTTP URLs like `https://subcog.io/mem/project/my-app/decisions/abc123`.

**Technical Details**:
- Standard HTTPS scheme
- Could be made resolvable via web service
- Well-understood format

**Pros**:
- Universally parseable
- Could provide web UI for memory viewing
- Standard URI format

**Cons**:
- Implies network dependency for resolution
- Requires domain ownership and maintenance
- Offline usage becomes awkward
- External service becomes a dependency
- Privacy concerns with centralized registry

**Why Rejected**: Subcog is designed as a local-first, offline-capable system. Requiring network access for identifier resolution contradicts this core principle.

### Option 4: Standard URN Format (Rejected)

**Description**: Use the official URN format: `urn:subcog:project:my-app:decisions:abc123`.

**Technical Details**:
- Follows RFC 8141 URN syntax
- Uses `:` as segment separator
- Namespace identifier is `subcog`

**Pros**:
- Official IETF standard
- Explicitly non-resolvable (no network implication)
- Registered namespace possible

**Cons**:
- Less readable due to `:` separators
- No authority component for domain encoding
- Requires URN-specific parsing (not generic URI)
- Uncommon in modern applications

**Why Rejected**: While technically correct, the colon-heavy syntax is less readable than slash-separated paths. Most developers are more familiar with URL-style URIs than formal URNs.

### Option 5: Custom URI Scheme (Accepted)

**Description**: Define a custom URI scheme `subcog://` with hierarchical path structure: `subcog://{domain}/{namespace}/{id}`.

**Technical Details**:
- Scheme: `subcog`
- Authority: domain with optional project/org name (e.g., `project:my-app`, `user`, `org:acme`)
- Path: `/{namespace}/{id}`
- ID includes version suffix (e.g., `abc1234:0` for version 0)

**Pros**:
- Valid URI per RFC 3986
- Human-readable hierarchy
- MCP resource compatible
- Standard library parsing
- Offline-friendly (no resolution implied)
- Extensible structure

**Cons**:
- Non-standard scheme requires documentation
- Longer than raw IDs
- Requires encoding for special characters
- Custom scheme registration for OS handlers

**Why Accepted**: Best balance of readability, standards compliance, and MCP compatibility. The custom scheme clearly identifies Subcog resources while maintaining URI parseability.

## Decision

We will adopt the URN scheme: `subcog://{domain}/{namespace}/{id}`

### Formal Grammar

```
subcog-urn    = "subcog://" domain "/" namespace "/" memory-id
domain        = domain-type [ ":" domain-name ]
domain-type   = "project" | "user" | "org"
domain-name   = 1*( ALPHA | DIGIT | "-" | "_" | "." )
namespace     = 1*( ALPHA | DIGIT | "-" | "_" )
memory-id     = short-id ":" version
short-id      = 12HEXDIG
version       = 1*DIGIT
```

### Component Descriptions

| Component | Description | Examples |
|-----------|-------------|----------|
| `subcog://` | URI scheme identifier, always literal | `subcog://` |
| `domain` | Scope ownership with optional qualifier | `project:my-app`, `user`, `org:acme-corp` |
| `namespace` | Logical category within the domain | `decisions`, `learnings`, `patterns`, `blockers` |
| `memory-id` | Unique identifier with version | `abc1234def5:0`, `789xyz012ab:3` |

### Canonical Examples

| Use Case | URN |
|----------|-----|
| Project decision | `subcog://project:my-app/decisions/abc1234def5:0` |
| User learning | `subcog://user/learnings/def5678901ab:1` |
| Organization pattern | `subcog://org:acme-corp/patterns/ghi9012345cd:0` |
| Project blocker | `subcog://project:backend-api/blockers/jkl3456789ef:0` |

### Version Semantics

The `:N` suffix on the memory ID represents the memory version:

- `:0` - Initial version (immutable once created)
- `:1`, `:2`, etc. - Subsequent updates (content-addressable)

Versions are monotonically increasing. Each version represents a complete snapshot, not a delta. The version is part of the identity; `abc1234:0` and `abc1234:1` are distinct resources.

### Reserved Namespaces

| Namespace | Purpose |
|-----------|---------|
| `decisions` | Architectural and technical decisions |
| `learnings` | Insights and discoveries during development |
| `patterns` | Reusable code patterns and solutions |
| `blockers` | Issues, obstacles, and workarounds |
| `context` | Background information and requirements |
| `_meta` | Reserved for system metadata (not user-facing) |

### Special URN Patterns

| Pattern | Meaning |
|---------|---------|
| `subcog://help` | Help system index |
| `subcog://help/{topic}` | Topic-specific help |
| `subcog://_` | List all memories across all domains |
| `subcog://project/_` | List all project-scoped memories |
| `subcog://user/_` | List all user-scoped memories |
| `subcog://org/_` | List all org-scoped memories |

## Consequences

### Positive

1. **Consistent Addressing Across Interfaces**: CLI commands, MCP tools, API endpoints, and internal references all use the same URN format. A developer can copy a URN from a log message and paste it into a CLI command or MCP resource request without transformation.

2. **MCP Resource Compatibility**: URNs map directly to MCP resource URIs. The MCP server exposes memories as resources using their URNs, enabling AI assistants to request specific memories by reference: `read_resource("subcog://project:my-app/decisions/abc1234:0")`.

3. **Human-Readable Format**: Unlike UUIDs, URNs convey semantic information at a glance. `subcog://project:backend-api/blockers/abc1234:0` immediately tells the reader this is a blocker in the backend-api project, not a learning or decision.

4. **Domain Hierarchy Encoded**: Permission checks and storage routing can be performed based solely on URN parsing. The domain portion (`project:my-app`, `user`, `org:acme`) determines which storage backend to query without additional lookups.

5. **Standard URI Library Support**: The URN format is compatible with standard URI parsing libraries. In Rust, the `url` crate correctly parses `subcog://project:my-app/decisions/abc1234:0` into scheme, host, and path components.

6. **Offline-First Design**: Unlike HTTPS URLs, the `subcog://` scheme does not imply network resolution. The scheme is explicitly local, supporting Subcog's offline-first architecture.

7. **Extensibility**: The URI format supports future extensions:
   - Query parameters: `subcog://project/decisions/abc?format=yaml`
   - Fragment identifiers: `subcog://project/decisions/abc#rationale`
   - Additional domains: `subcog://team:frontend/patterns/xyz`

### Negative

1. **Longer Than Simple IDs**: URNs are significantly larger than raw identifiers. A 12-character short ID becomes a 60+ character URN when fully qualified:

   | Format | Length | Example |
   |--------|--------|---------|
   | Short ID | 12 chars | `abc1234def5` |
   | With version | 14 chars | `abc1234def5:0` |
   | Full URN | 55-70 chars | `subcog://project:my-app/decisions/abc1234def5:0` |

   This increases storage overhead in databases, logs, and network payloads by approximately 5x.

   **Mitigation**: Store the short ID internally and construct URNs on-demand for external interfaces. Use the short ID for internal references (foreign keys, indexes) and only serialize to full URN format at API boundaries. The database schema stores only the short ID; the URN is computed at query time. For bulk exports, apply gzip compression which efficiently compresses the repetitive URN prefixes.

2. **Percent-Encoding Required**: Special characters in domain names, namespaces, or IDs must be percent-encoded per RFC 3986 Section 2.1. Characters requiring encoding include:

   | Character | Encoded | Context |
   |-----------|---------|---------|
   | Space | `%20` | Project names with spaces |
   | Colon (non-delimiter) | `%3A` | Values containing colons |
   | Slash | `%2F` | Values containing path separators |
   | Question mark | `%3F` | Values with query-like content |
   | Unicode | `%XX%YY` | Non-ASCII characters |

   Example: A project named "my app/v2" becomes `subcog://project:my%20app%2Fv2/decisions/abc123:0`.

   **Mitigation**: Implement a normalization layer that handles encoding/decoding consistently. Validate domain and namespace values at creation time, rejecting or transforming problematic characters. Provide helper functions `urn_encode()` and `urn_decode()` in all client libraries. The recommended approach is to restrict project names to `[a-zA-Z0-9_-]` at validation time.

3. **Version Information Limitations**: The current URN scheme encodes version as a suffix on the ID (`:0`, `:1`) rather than as a separate URI component. This design choice has limitations:

   - Cannot express version ranges (e.g., "all versions of memory X")
   - Cannot distinguish "latest version" from "specific version" in the URN itself
   - Version is conflated with identity rather than being a separate dimension

   **Future Extension Format**: If sophisticated versioning becomes necessary, the scheme can be extended:
   - Specific version: `subcog://project/decisions/abc1234@v2`
   - Latest version: `subcog://project/decisions/abc1234@latest`
   - Version range: `subcog://project/decisions/abc1234?v=1..3`

   For now, the workaround is to treat each version as a distinct ID (`abc1234:0`, `abc1234:1`) and use the search API with filters to find version history.

### Neutral

1. **Scope Boundaries**: URNs address individual memories but do not provide semantics for:

   - **Collections**: No syntax for "all memories in namespace X" exists in the URN itself. The special `_` pattern (`subcog://project/_`) is a convention for listing, not a true collection URN. Use the search API for filtered results.

   - **Query Expressions**: URNs identify resources, not query results. A URN like `subcog://project/decisions/*` is not valid. Use dedicated query endpoints with filter parameters for complex queries.

   - **Wildcards**: No glob or regex matching in URNs. `subcog://project/*/abc123` is not supported. Filter results client-side or use the search API.

   - **Cross-Domain References**: URNs are scoped to a single domain. A memory cannot belong to both `project:app-a` and `project:app-b`. Cross-domain linking requires explicit relationship modeling through memory content or metadata.

2. **No Resolution Protocol**: Unlike `http://` or `ftp://` URIs, `subcog://` URNs do not define a resolution protocol. There is no standard for how a client should resolve `subcog://project/decisions/abc123:0` into actual content. Resolution is implementation-defined:
   - CLI: `subcog get subcog://project/decisions/abc123:0`
   - MCP: `read_resource("subcog://project/decisions/abc123:0")`
   - API: `GET /api/v1/memories/abc123?version=0`

3. **Custom Scheme Registration**: To enable OS-level URI handlers (clicking a `subcog://` link opens Subcog), each platform requires custom scheme registration:
   - macOS: `Info.plist` CFBundleURLTypes
   - Linux: `.desktop` file with MimeType
   - Windows: Registry HKEY_CLASSES_ROOT

   This registration is optional and does not affect programmatic URN handling.

## Decision Outcome

The URN scheme `subcog://{domain}/{namespace}/{id}` provides a foundation for MCP resources, CLI operations, and future API extensions. The format successfully balances:

- **Readability**: Developers can understand URNs without documentation
- **Standards Compliance**: Generic URI parsers work correctly
- **MCP Integration**: Direct mapping to MCP resource model
- **Extensibility**: Room for future parameters and fragments

The implementation in `src/services/capture.rs` generates URNs at capture time, storing the short ID in the database while computing full URNs for external interfaces. The MCP resource handlers in `src/mcp/resources.rs` parse incoming URNs to route requests to the appropriate storage backend.

## Implementation Notes

### URN Generation

URNs are generated in `src/services/capture.rs` during memory capture. The short ID is derived from a SHA-256 hash of the memory content, truncated to 12 hex characters. The version starts at 0 and increments with each update.

```rust
// Pseudocode for URN generation
fn generate_urn(domain: &Domain, namespace: &str, content: &str, version: u32) -> String {
    let hash = sha256(content);
    let short_id = &hex::encode(hash)[..12];
    format!("subcog://{}/{}/{}:{}", domain, namespace, short_id, version)
}
```

### URN Parsing

URN parsing uses the standard `url` crate with additional validation for Subcog-specific components:

```rust
// Pseudocode for URN parsing
fn parse_urn(urn: &str) -> Result<UrnComponents> {
    let url = Url::parse(urn)?;
    ensure!(url.scheme() == "subcog");
    let domain = url.host_str()?;
    let path_segments: Vec<&str> = url.path_segments()?.collect();
    ensure!(path_segments.len() == 2);
    let namespace = path_segments[0];
    let id_version = path_segments[1];
    // Parse id:version format
    ...
}
```

### Storage Mapping

| URN Domain | Storage Backend | Location |
|------------|-----------------|----------|
| `project:*` | SQLite | `.subcog/memory.db` in repository root |
| `user` | SQLite | `~/.subcog/user/memory.db` |
| `org:*` | PostgreSQL | Configured via `SUBCOG_ORG_DATABASE_URL` |

## Links

- **RFC 3986**: URI Generic Syntax - https://www.rfc-editor.org/rfc/rfc3986
- **RFC 8141**: URN Syntax - https://www.rfc-editor.org/rfc/rfc8141
- **MCP Resource Specification**: https://modelcontextprotocol.io/docs/concepts/resources

## Related Decisions

- **ADR-0001**: Three-Layer Storage Architecture (defines the storage backends URNs route to)
- **ADR-0009**: rmcp for MCP Server Implementation (MCP server that exposes URNs as resources)
- **ADR-0054**: Notification Detection (MCP protocol handling for URN-based resources)

## More Information

- **Date:** 2025-12-28
- **Source:** SPEC-2025-12-28: Subcog Rust Rewrite

## Audit

### 2026-01-04

**Status:** Violated

**Findings:**

| Finding | Files | Lines | Assessment |
|---------|-------|-------|------------|
| URN generation omits the `mem` segment | `src/services/capture.rs` | L330-L344 | violation |

**Summary:** URNs are generated without the `/mem/` segment required by the ADR.

**Action Required:** Align URN format to `subcog://{domain}/{namespace}/{id}` or update the ADR.

### 2026-01-04

**Status:** Compliant

**Findings:**

| Finding | Files | Lines | Assessment |
|---------|-------|-------|------------|
| URN generator uses `subcog://{domain}/{namespace}/{id}` format | `src/services/capture.rs` | L352-L366 | compliant |

**Summary:** URN generation follows the ADR format for domain, namespace, and ID segments.

**Action Required:** None
