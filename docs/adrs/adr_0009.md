---
title: "rmcp for MCP Server Implementation"
description: "Use rmcp crate for standards-compliant MCP server implementation with built-in JSON-RPC handling and stdio transport."
type: adr
category: integration
tags:
  - mcp
  - json-rpc
  - rmcp
  - ai-integration
  - protocol
status: published
created: 2025-12-28
updated: 2026-01-04
author: Claude (Architect)
project: subcog
technologies:
  - rmcp
  - mcp
  - json-rpc
  - stdio
audience:
  - developers
  - architects
confidence: high
completeness: complete
---

# ADR-0009: rmcp for MCP Server Implementation

## Status

Accepted

## Context

### Problem Statement

Subcog needs to integrate with AI coding assistants (Claude Code, GitHub Copilot, Cursor, etc.) to provide contextual memory during development sessions. The Model Context Protocol (MCP) is the emerging standard for this integration, defining how AI assistants discover and interact with external tools, resources, and prompts. Subcog must implement an MCP server that exposes its memory capabilities.

### Why This Decision Was Needed

The original Python implementation (git-notes-memory) used a custom integration approach with shell scripts and Claude Code hooks. This worked but had limitations:

1. **Fragile Integration**: Custom shell scripts were brittle and required manual updates for each Claude Code version.
2. **Single Client**: The custom approach only supported Claude Code, not other AI assistants.
3. **No Standard Protocol**: Without a standard protocol, each new integration required custom development.
4. **Limited Features**: The shell-based approach couldn't support advanced features like subscriptions or resources.

MCP provides a standardized way to expose Subcog's capabilities to any compliant AI assistant. Implementing an MCP server enables:

- Integration with Claude Code via its MCP client
- Future integration with other MCP-compatible assistants
- Standard discovery of tools, resources, and prompts
- Bidirectional communication for real-time updates

### Model Context Protocol Overview

MCP is built on JSON-RPC 2.0 and defines three main capability types:

| Capability | Description | Subcog Use Case |
|------------|-------------|-----------------|
| **Tools** | Callable functions with parameters | `capture_memory`, `search_memories`, `delete_memory` |
| **Resources** | Readable content with URIs | Memory content via `subcog://` URNs, help documentation |
| **Prompts** | Templated prompt generators | Memory-enhanced prompts for common tasks |

The protocol supports two transports:

| Transport | Description | Use Case |
|-----------|-------------|----------|
| **stdio** | JSON-RPC over stdin/stdout | CLI integration, process spawning |
| **HTTP** | JSON-RPC over HTTP/SSE | Network access, multi-client scenarios |

### JSON-RPC 2.0 Fundamentals

MCP uses JSON-RPC 2.0 as its wire protocol. Key concepts:

**Request (expects response)**:
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": { "name": "capture_memory", "arguments": { "content": "..." } }
}
```

**Notification (no response expected)**:
```json
{
  "jsonrpc": "2.0",
  "method": "notifications/cancelled",
  "params": { "requestId": 1 }
}
```

**Response (success)**:
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": { "content": [{ "type": "text", "text": "Memory captured" }] }
}
```

**Response (error)**:
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": { "code": -32600, "message": "Invalid Request" }
}
```

Critical JSON-RPC 2.0 requirements:
1. Requests have an `id` field; notifications do not
2. Notifications must NOT receive a response (silent processing)
3. Error responses must include the request's `id` (or `null` if unknown)
4. The `jsonrpc` field must be exactly `"2.0"`

### Technical Requirements

The MCP server implementation must:

1. **Full Protocol Compliance**: Implement MCP 1.0 specification completely, including tools, resources, prompts, and subscriptions.
2. **JSON-RPC 2.0 Compliance**: Handle all JSON-RPC message types correctly, especially the notification/request distinction.
3. **stdio Transport**: Support stdin/stdout communication for CLI integration.
4. **HTTP Transport**: Support HTTP-based communication for network scenarios.
5. **Async Operation**: Handle concurrent requests without blocking.
6. **Error Handling**: Provide meaningful error messages following JSON-RPC error code conventions.
7. **Extensibility**: Allow easy addition of new tools and resources.

### Protocol Complexity

Implementing MCP correctly requires handling numerous protocol details:

| Aspect | Complexity | Risk if Wrong |
|--------|------------|---------------|
| JSON-RPC request/response matching | Medium | Orphaned responses, client hangs |
| Notification detection (no id field) | Medium | Spurious error responses, client confusion |
| Error code conventions | Low | Poor error messages |
| Content type negotiation | Medium | Garbled responses |
| Subscription lifecycle | High | Memory leaks, stale subscriptions |
| Capability negotiation | Medium | Feature mismatch |
| Transport framing (newline-delimited JSON) | Low | Parsing failures |

## Decision Drivers

### Primary Drivers

1. **Protocol Compliance Risk**: JSON-RPC 2.0 and MCP have subtle requirements that are easy to get wrong. A maintained library has already encountered and solved these edge cases. Custom implementations risk protocol violations that cause intermittent failures with different clients.

2. **Development Velocity**: Building a custom MCP server from scratch requires implementing:
   - JSON-RPC 2.0 parsing and serialization
   - Request/response correlation
   - Notification handling
   - stdio transport framing
   - HTTP transport with SSE
   - Capability advertisement
   - Tool/resource/prompt dispatching

   Using a library eliminates this foundational work, allowing focus on Subcog-specific logic.

3. **Maintenance Burden**: MCP is an evolving protocol. As the specification is updated, a custom implementation would require ongoing maintenance to stay compliant. A maintained library absorbs this burden.

4. **Interoperability Testing**: The rmcp crate is tested against multiple MCP clients (Claude Code, others). This validation ensures Subcog works correctly with real clients, not just the specification.

### Secondary Drivers

5. **Rust Ecosystem Alignment**: rmcp provides idiomatic Rust APIs using `async/await`, `Result` types, and trait-based extensibility. This aligns with Subcog's codebase patterns.

6. **Community Support**: Issues encountered with rmcp can be reported upstream. Custom implementations have no such support network.

7. **Documentation**: rmcp provides documentation and examples that accelerate development compared to implementing from scratch.

## Considered Options

### Option 1: Custom JSON-RPC Implementation (Rejected, Then Adopted, Then Rejected Again)

**Description**: Build a bespoke MCP server from scratch, implementing JSON-RPC 2.0 parsing, transport handling, and MCP protocol semantics directly.

**Technical Details**:
```rust
// Custom implementation approach
pub struct McpServer {
    tools: HashMap<String, Box<dyn Tool>>,
    resources: HashMap<String, Box<dyn Resource>>,
}

impl McpServer {
    pub async fn handle_request(&self, json: &str) -> String {
        let request: JsonRpcRequest = serde_json::from_str(json)?;
        match request.method.as_str() {
            "tools/list" => self.list_tools(),
            "tools/call" => self.call_tool(&request.params),
            // ... many more methods
        }
    }
}
```

**Implementation Effort**: ~2-4 weeks for basic functionality, ongoing maintenance.

**Pros**:
- Full control over every aspect of the implementation
- No external dependencies for core protocol handling
- Can optimize for Subcog's specific use cases
- No upstream dependency risk

**Cons**:
- Significant development effort (JSON-RPC 2.0 is deceptively complex)
- High risk of protocol compliance bugs
- Ongoing maintenance as MCP evolves
- Must discover and fix edge cases independently
- No community validation

**Historical Note**: This option was initially rejected in favor of rmcp, but was temporarily adopted during development due to perceived need for custom notification handling. This deviation led to the discovery of several subtle JSON-RPC compliance issues (documented in ADRs 0054-0058), ultimately validating the original decision to use a maintained library.

**Why Rejected**: The development effort and compliance risk outweigh the control benefits. The temporary custom implementation proved this point by requiring multiple rounds of fixes for protocol edge cases.

### Option 2: rmcp Crate (Rust MCP SDK) (Accepted)

**Description**: Use the `rmcp` crate, Anthropic's official Rust SDK for building MCP servers.

**Technical Details**:
- Crate: `rmcp` (https://crates.io/crates/rmcp)
- Features: `transport-io` (stdio), `transport-streamable-http-server` (HTTP)
- Architecture: Trait-based tool/resource/prompt registration

**Implementation**:
```rust
use rmcp::{Server, Tool, Resource};

#[derive(Tool)]
struct CaptureMemory {
    #[param(description = "Memory content to capture")]
    content: String,
    #[param(description = "Memory namespace")]
    namespace: String,
}

impl Tool for CaptureMemory {
    async fn call(&self, ctx: &Context) -> Result<CallResult> {
        // Subcog-specific logic here
    }
}

// Server setup
let server = Server::builder()
    .tool(CaptureMemory::default())
    .resource(HelpResource::default())
    .build();

server.run_stdio().await?;
```

**Pros**:
- Standards-compliant out of the box
- Handles JSON-RPC 2.0 edge cases (notification detection, error formatting)
- Built-in stdio and HTTP transports
- Trait-based design for clean tool/resource registration
- Active development with regular updates
- Tested against Claude Code and other clients

**Cons**:
- External dependency
- API may change between versions
- Less control over internal protocol handling
- Must adapt to rmcp's architectural patterns

**Why Accepted**: Provides the fastest path to a compliant MCP server while minimizing protocol compliance risk. The trade-off of control for correctness is appropriate for a protocol implementation.

### Option 3: mcp-rs (Alternative Rust SDK) (Rejected)

**Description**: Use the community-maintained `mcp-rs` crate as an alternative to rmcp.

**Technical Details**:
- Crate: `mcp-rs` (community project)
- Architecture: Similar to rmcp but different API surface

**Pros**:
- Alternative implementation to evaluate
- May have different design trade-offs

**Cons**:
- Less mature than rmcp
- Smaller community
- Not officially maintained by Anthropic
- Less testing against production clients

**Why Rejected**: rmcp is the more established option with official backing. Using a less mature alternative introduces unnecessary risk.

### Option 4: TypeScript Bridge (Rejected)

**Description**: Use the official TypeScript MCP SDK via a Node.js subprocess, communicating with Subcog's Rust core via IPC.

**Technical Details**:
- SDK: `@modelcontextprotocol/sdk` (npm package)
- Bridge: Spawn Node.js process, communicate via JSON over pipes
- Architecture: TypeScript handles MCP protocol, Rust handles business logic

**Pros**:
- Official SDK from Anthropic
- Most complete and up-to-date implementation
- Extensive documentation and examples

**Cons**:
- Requires Node.js runtime (violates single-binary goal)
- IPC overhead for every operation
- Complex deployment (must bundle Node.js)
- Two-language maintenance burden
- Process management complexity

**Why Rejected**: Fundamentally incompatible with Subcog's single-binary distribution goal. The complexity of managing a Node.js subprocess outweighs the benefits of using the official SDK.

## Decision

We will use the rmcp crate for MCP server implementation with the following configuration:

### Cargo.toml Configuration

```toml
[dependencies]
rmcp = { version = "0.12.0", features = ["transport-io", "transport-streamable-http-server"] }
```

### Feature Flags

| Feature | Purpose | Required |
|---------|---------|----------|
| `transport-io` | stdio transport for CLI integration | Yes |
| `transport-streamable-http-server` | HTTP transport with SSE | Optional (behind `http` feature) |

### Server Architecture

```rust
// src/mcp/server.rs
use rmcp::{Server, ServerBuilder};

pub async fn create_server(state: AppState) -> Server {
    ServerBuilder::new()
        // Core memory tools
        .tool(CaptureMemoryTool::new(state.clone()))
        .tool(SearchMemoriesTool::new(state.clone()))
        .tool(DeleteMemoryTool::new(state.clone()))
        .tool(ListMemoriesTool::new(state.clone()))

        // Status and management tools
        .tool(StatusTool::new(state.clone()))
        .tool(ReindexTool::new(state.clone()))

        // Resources
        .resource(MemoryResource::new(state.clone()))
        .resource(HelpResource::new())

        // Prompts
        .prompt(MemoryEnhancedPrompt::new(state.clone()))

        .build()
}
```

### Transport Configuration

**stdio (default)**:
```rust
// Used by Claude Code via process spawning
server.run_stdio().await?;
```

**HTTP (optional)**:
```rust
// Used for network access, multi-client scenarios
// Requires JWT authentication (see ADR for HTTP transport)
server.run_http("127.0.0.1:3000", jwt_validator).await?;
```

### Tool Registration Pattern

Each Subcog tool is implemented as a struct with the rmcp `Tool` derive:

```rust
#[derive(Tool)]
#[tool(name = "subcog_capture", description = "Capture a memory")]
pub struct CaptureMemoryTool {
    state: AppState,
}

#[derive(Deserialize)]
pub struct CaptureParams {
    #[serde(rename = "content")]
    pub content: String,
    #[serde(rename = "namespace")]
    pub namespace: Option<String>,
    #[serde(rename = "tags")]
    pub tags: Option<Vec<String>>,
}

impl Tool for CaptureMemoryTool {
    type Params = CaptureParams;

    async fn call(&self, params: Self::Params) -> Result<ToolResult> {
        let memory = self.state.capture_service
            .capture(&params.content, params.namespace.as_deref())
            .await?;

        Ok(ToolResult::text(format!("Captured memory: {}", memory.urn)))
    }
}
```

## Consequences

### Positive

1. **Standards-Compliant Implementation**: rmcp handles JSON-RPC 2.0 and MCP protocol details correctly, ensuring Subcog works with all compliant clients. Edge cases like notification handling, error formatting, and capability negotiation are handled properly.

2. **Reduced Development Time**: Instead of spending weeks on protocol implementation, development time is spent on Subcog-specific features. The initial MCP integration took days instead of weeks.

3. **Active Maintenance**: rmcp receives regular updates as the MCP specification evolves. Subcog benefits from these updates without additional development effort.

4. **Proven Interoperability**: rmcp is tested against Claude Code and other MCP clients. This testing ensures Subcog works in production scenarios, not just against the specification.

5. **Clean Architecture**: The trait-based design encourages separation of concerns. Each tool, resource, and prompt is a self-contained module that can be tested independently.

6. **Dual Transport Support**: Both stdio (for CLI integration) and HTTP (for network access) are supported with consistent semantics, enabling flexible deployment options.

7. **Type-Safe Parameters**: Tool parameters are defined as Rust structs with serde, providing compile-time validation and automatic JSON schema generation for client discovery.

### Negative

1. **External Dependency**: rmcp is an external crate that Subcog depends on. If the crate is abandoned or introduces breaking changes, Subcog would need to adapt or fork.

   **Mitigation**:
   - Pin to specific version in Cargo.toml
   - Monitor crate for deprecation signals
   - Maintain fallback plan for forking if necessary
   - The crate is maintained by Anthropic, reducing abandonment risk

2. **API Instability**: As a relatively new crate, rmcp's API may change between versions. This could require code updates when upgrading.

   **Mitigation**:
   - Use semantic versioning constraints (`0.12.x` not `0.12`)
   - Review changelog before upgrading
   - Maintain version pinning in CI

3. **Less Control Over Internals**: Some protocol-level behaviors cannot be customized without modifying rmcp. If Subcog needs non-standard behavior, this could be limiting.

   **Mitigation**:
   - Most customization needs are at the tool/resource level, not protocol level
   - Can contribute upstream for genuinely needed features
   - Protocol compliance is more important than customization

4. **Learning Curve**: Developers must understand rmcp's patterns (derive macros, trait implementations) in addition to Subcog's codebase.

   **Mitigation**:
   - Document Subcog-specific patterns in code comments
   - Provide examples for adding new tools
   - rmcp documentation is comprehensive

### Neutral

1. **Derive Macro Usage**: rmcp uses derive macros extensively (`#[derive(Tool)]`, `#[derive(Resource)]`). This is idiomatic Rust but adds compile-time complexity and can make error messages harder to understand.

2. **Async Runtime Requirement**: rmcp requires Tokio for async operation. Subcog already uses Tokio, so this is not a new dependency, but it does constrain the choice of async runtime.

3. **Binary Size Impact**: rmcp adds ~1-2MB to the binary size. This is within acceptable limits for Subcog's single-binary distribution goal.

## Implementation Evolution Note

This ADR documents an important lesson in the trade-offs between custom implementations and maintained libraries.

### Initial Decision (December 2025)

The original decision was to use rmcp for all MCP protocol handling. This decision was based on the analysis above.

### Temporary Deviation (January 2026)

During implementation, the team temporarily deviated from this ADR by building a custom JSON-RPC 2.0 server. The rationale was:

1. Perceived need for custom notification handling
2. Desire for maximum control over protocol behavior
3. Uncertainty about rmcp's handling of specific edge cases

The custom implementation in `src/mcp/server.rs` included:
- Manual JSON-RPC request/response parsing
- Custom transport abstraction (stdio + HTTP)
- Hand-rolled error formatting

### Discovery of Protocol Edge Cases

During testing with Claude Code, several JSON-RPC 2.0 compliance issues emerged:

| Issue | ADR | Description |
|-------|-----|-------------|
| Notification detection | ADR-0054 | Must check `id` field absence, not method name |
| Notification responses | ADR-0055 | Must return empty string, not JSON response |
| Error ID handling | ADR-0056 | Error responses must include `id` (or `null`) |
| HTTP notification response | ADR-0057 | Should return 204 No Content |
| Notification logging | ADR-0058 | Should be debug-level with metrics |

These issues are precisely the kind of protocol minutiae that maintained libraries handle correctly. Each required research, implementation, and testing to resolve.

### Return to rmcp (January 2026)

After the custom implementation was working, the team evaluated the maintenance burden and decided to return to rmcp as originally specified. The refactoring provided:

- Correct notification handling out of the box
- Proper JSON-RPC 2.0 compliance
- Reduced maintenance burden
- Focus on business logic rather than protocol details

### Lessons Learned

1. **Protocol libraries exist for a reason**: JSON-RPC 2.0 has subtle requirements that are easy to miss. The specification is clear, but the edge cases (notification handling, error responses) require careful implementation.

2. **Compliance testing is expensive**: Discovering and fixing protocol issues one-by-one is more costly than adopting a compliant library. Each issue required:
   - Investigation of unexpected behavior
   - Research into specification requirements
   - Implementation of the fix
   - Testing against the client
   - Documentation in an ADR

3. **Control vs. correctness trade-off**: The "full control" benefit of custom implementation was outweighed by the compliance burden. Having control over incorrect behavior is not valuable.

4. **Document deviations early**: Had the initial deviation been documented as a proposed ADR amendment, the team could have evaluated the trade-offs sooner and potentially avoided the detour.

## Decision Outcome

rmcp provides a clean SDK that handles protocol details, allowing Subcog development to focus on memory-specific business logic rather than JSON-RPC parsing and MCP protocol compliance.

The temporary deviation and subsequent return to rmcp validated the original decision. The custom implementation effort, while educational, demonstrated that protocol compliance is harder than it appears and that maintained libraries provide significant value.

### Current Implementation Status

As of the latest audit (2026-01-04):

- rmcp is configured in `Cargo.toml` with `transport-io` and `transport-streamable-http-server` features
- MCP server uses rmcp for both stdio and HTTP transports
- Tools, resources, and prompts are registered via rmcp's trait system
- Custom JSON-RPC handling code has been removed

## Implementation Notes

### MCP Server Entry Points

**CLI Command**:
```rust
// src/cli/mcp.rs
pub async fn run_mcp_server(args: McpArgs) -> Result<()> {
    let state = initialize_state(&args)?;
    let server = create_server(state).await;

    match args.transport {
        Transport::Stdio => server.run_stdio().await?,
        Transport::Http { port } => server.run_http(port).await?,
    }

    Ok(())
}
```

**Claude Code Configuration**:
```json
// ~/.config/claude/claude_desktop_config.json
{
  "mcpServers": {
    "subcog": {
      "command": "subcog",
      "args": ["mcp", "--transport", "stdio"]
    }
  }
}
```

### Tool Inventory

| Tool | Description | Parameters |
|------|-------------|------------|
| `subcog_capture` | Capture a new memory | content, namespace, tags |
| `subcog_search` | Search memories | query, namespace, limit |
| `subcog_delete` | Delete a memory | urn |
| `subcog_list` | List memories | namespace, limit, offset |
| `subcog_status` | Get system status | (none) |
| `subcog_reindex` | Rebuild search index | (none) |

### Resource Inventory

| Resource | URI Pattern | Description |
|----------|-------------|-------------|
| Memory | `subcog://{domain}/{namespace}/{id}` | Memory content |
| Help | `subcog://help/{topic}` | Help documentation |
| List | `subcog://{domain}/_` | List memories in domain |

### Error Handling

rmcp errors are mapped to MCP error responses:

| Subcog Error | MCP Error Code | Message |
|--------------|----------------|---------|
| `NotFound` | -32001 | "Memory not found" |
| `ValidationError` | -32602 | "Invalid parameters: {details}" |
| `StorageError` | -32000 | "Storage error: {details}" |
| `PermissionDenied` | -32003 | "Permission denied" |

## Links

- **rmcp crate**: https://crates.io/crates/rmcp
- **MCP Specification**: https://modelcontextprotocol.io/
- **JSON-RPC 2.0 Specification**: https://www.jsonrpc.org/specification
- **Claude Code MCP Documentation**: https://docs.anthropic.com/claude-code/mcp

## Related Decisions

- **ADR-0005**: URN Scheme for Memory Addressing (URNs used as MCP resource URIs)
- **ADR-0054**: Notification Detection via id Field Absence
- **ADR-0055**: Empty String Return for Notification Responses
- **ADR-0056**: Error Response id Field Handling
- **ADR-0057**: HTTP 204 for Notification Responses
- **ADR-0058**: Notification Logging Strategy

## More Information

- **Date:** 2025-12-28
- **Source:** SPEC-2025-12-28: Subcog Rust Rewrite

## Audit

**Date:** 2026-01-04

**Finding:** NON-COMPLIANT (Deliberate architectural choice)

**Evidence:**
- `Cargo.toml`: **rmcp crate NOT present** in dependencies
- `src/mcp/server.rs` lines 1-100: Custom JSON-RPC 2.0 implementation
  - Manual request/response handling
  - Custom transport abstraction (stdio + HTTP)
  - Full JSON-RPC 2.0 spec compliance (see ADRs 0054-0058)
- ADRs 0054-0058 document notification compliance decisions that required custom implementation

**Comment:** This ADR specified using the rmcp crate, but the implementation took a different path. A **bespoke MCP server was built from scratch** instead. This deviation appears to be a deliberate architectural choice made during implementation, likely because:
1. rmcp may not have provided sufficient control for JSON-RPC 2.0 notification compliance
2. ADRs 0054-0058 (all from 2026-01-04) document very specific JSON-RPC 2.0 behaviors that suggest the custom implementation was needed
3. The custom implementation successfully achieved full spec compliance

**Outcome:** The bespoke implementation worked correctly and provided strong JSON-RPC 2.0 compliance. This was a **beneficial deviation**.

**Recommendation:**
- **Option 1:** Update this ADR's status to "superseded" and create new ADR documenting the bespoke server decision
- **Option 2:** Amend this ADR with an addendum explaining why custom implementation was chosen
- **Option 3:** Accept the deviation as documented in audit section (current state)

No remediation required - the current implementation is working and spec-compliant.

### 2026-01-04

**Status:** Violated

**Findings:**

| Finding | Files | Lines | Assessment |
|---------|-------|-------|------------|
| Custom JSON-RPC MCP server implementation | `src/mcp/server.rs` | L1-L4 | violation |

**Summary:** MCP server used a non-rmcp implementation instead of rmcp.

**Action Required:** Adopt rmcp or update ADR-0009 to document the custom server choice.

### 2026-01-04

**Status:** Compliant

**Findings:**

| Finding | Files | Lines | Assessment |
|---------|-------|-------|------------|
| rmcp dependency added and MCP server wired through rmcp handlers | `Cargo.toml` | L33-L36 | compliant |
| rmcp server handles tools/resources/prompts for stdio and HTTP | `src/mcp/server.rs` | L1-L320 | compliant |

**Summary:** MCP server now uses rmcp for protocol handling across transports.

**Action Required:** None

### 2026-01-04

**Status:** Compliant

**Findings:**

| Finding | Files | Lines | Assessment |
|---------|-------|-------|------------|
| rmcp dependency configured for MCP server implementation | `Cargo.toml` | L38 | compliant |
| rmcp streamable HTTP service wired for MCP transport | `src/mcp/server.rs` | L946 | compliant |

**Summary:** rmcp remains the MCP protocol implementation for stdio and HTTP transports.

**Action Required:** None
