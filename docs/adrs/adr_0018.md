---
title: "Content Hash Storage as Tags"
description: "Store SHA256 content hashes as tags (hash:sha256:<16-char-prefix>) for fast exact-match lookup without schema migration."
type: adr
category: storage
tags:
  - content-hash
  - sha256
  - deduplication
  - tags
  - sqlite
status: published
created: 2026-01-01
updated: 2026-01-04
author: Claude (Architect)
project: subcog
audience:
  - developers
  - architects
confidence: high
completeness: complete
---

# ADR-0018: Content Hash Storage as Tags

## Status

Accepted

## Context

To enable fast exact-match lookup, we need to store a content hash with each memory. Options include: new schema column, metadata field, or tags.

## Decision Drivers

### Primary Decision Drivers

1. **No Migration Required**: The solution should work with the existing schema without requiring database migrations.

2. **Leverage Existing Infrastructure**: The tag search system and SQLite FTS5 index are already optimized and battle-tested.

3. **Query Performance**: Exact-match lookups must be fast (sub-millisecond) for the deduplication hot path.

### Secondary Decision Drivers

1. **Future Extensibility**: The tag prefix format (`hash:sha256:`) allows supporting multiple hash algorithms in the future.

2. **Storage Efficiency**: While not the most compact representation, the overhead is acceptable for the flexibility gained.

## Decision

We will store SHA256 hash as a tag with format `hash:sha256:<16-char-prefix>`.

## Consequences

### Positive

- No schema migration required
- Works with existing tag search infrastructure
- SQLite FTS5 index already optimized for tag queries
- Tag prefix allows for multiple hash algorithms in future

### Negative

- Tag storage slightly less efficient than dedicated column
- Truncated to 16 chars (collision unlikely but possible)
- Pollutes tag namespace

### Neutral

- Hash tag is transparent to users querying by regular tags

## Considered Options

### Option 1: New Schema Column

**Description**: Add a dedicated `content_hash` column to the memories table.

**Advantages**: Most efficient lookup, clean data model.

**Disadvantages**: Requires database migration, schema versioning complexity.

### Option 2: Metadata JSON Field

**Description**: Store the hash in a JSON metadata field.

**Advantages**: Flexible, no schema change.

**Disadvantages**: No index support, slow lookups.

### Option 3: Separate Hash Table

**Description**: Create a dedicated table mapping hashes to memory IDs.

**Advantages**: Clean separation, efficient lookups.

**Disadvantages**: More complex implementation, additional storage layer.

### Option 4: Tag-Based Storage (Selected)

**Description**: Store hash as a tag with prefix format `hash:sha256:<prefix>`.

**Advantages**: No migration, leverages existing FTS5 index, future-extensible.

**Disadvantages**: Slightly less efficient, pollutes tag namespace.

## More Information

- **Date:** 2026-01-01
- **Source:** SPEC-2026-01-01-001: Pre-Compact Deduplication

## Audit

### 2026-01-04

**Status:** Partial

**Findings:**

| Finding | Files | Lines | Assessment |
|---------|-------|-------|------------|
| Hash tag format `hash:sha256:<prefix>` implemented | `src/services/deduplication/hasher.rs` | L61-L91 | compliant |
| Capture stores tags only from request without hash tag | `src/services/capture.rs` | L223-L234 | gap |

**Summary:** Hash tag format exists, but capture does not add hash tags to stored memories.

**Action Required:** Append the hash tag to memory.tags during capture.

### 2026-01-04

**Status:** Compliant

**Findings:**

| Finding | Files | Lines | Assessment |
|---------|-------|-------|------------|
| Capture appends `hash:sha256:<prefix>` tag during memory creation | `src/services/capture.rs` | L235-L238 | compliant |

**Summary:** Capture now injects hash tags into stored memory tags as required.

**Action Required:** None
