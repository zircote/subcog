---
title: "Regex-Based Code Block Detection"
description: "Use regex pattern with LazyLock for static compilation to detect fenced code blocks, consistent with existing codebase patterns."
type: adr
category: parsing
tags:
  - regex
  - code-blocks
  - markdown
  - lazylock
  - rust
status: published
created: 2026-01-01
updated: 2026-01-04
author: Claude (Architect)
project: subcog
technologies:
  - rust
  - regex
audience:
  - developers
  - architects
confidence: high
completeness: complete
---

# ADR-0028: Regex-Based Code Block Detection

## Status

Accepted

## Context

How to detect fenced code blocks in content?

- Full Markdown parser (pulldown-cmark, comrak)
- Custom regex pattern
- Character-by-character state machine

## Decision Drivers

### Primary Decision Drivers

1. **Codebase Consistency**: The existing codebase uses LazyLock regex patterns for similar detection tasks (secrets.rs, pii.rs). Following this pattern maintains consistency.

2. **No New Dependencies**: Regex is already a dependency; adding a Markdown parser would increase binary size and complexity.

3. **Performance**: Compiled regex patterns with LazyLock provide fast execution (<1ms) suitable for the hot path.

### Secondary Decision Drivers

1. **Simplicity**: Regex patterns are easier to understand and maintain than state machines for this specific use case.

2. **Testability**: Regex behavior is well-documented and easy to test with specific input patterns.

## Decision

We will use a **regex pattern** with LazyLock for static compilation.

```rust
static CODE_BLOCK_PATTERN: LazyLock<Regex> = LazyLock::new(|| {
    Regex::new(r"```([a-zA-Z0-9_-]*)\n([\s\S]*?)```")
        .expect("static regex: code block pattern")
});
```

## Consequences

### Positive

- Consistent with existing codebase patterns (secrets.rs, pii.rs)
- No new dependencies
- Fast execution (<1ms)
- Simple to understand and maintain

### Negative

- May not handle all edge cases (nested, escaped)
- Less robust than full parser

### Neutral

- Pattern covers the 85%+ common case of fenced code blocks

## Considered Options

### Option 1: Full Markdown Parser (pulldown-cmark)

**Description**: Use a complete Markdown parser to identify code blocks.

**Advantages**: Handles all Markdown edge cases correctly.

**Disadvantages**: Heavyweight dependency for this specific use case, slower execution.

### Option 2: Character-by-Character State Machine

**Description**: Implement a custom parser that tracks state while scanning content.

**Advantages**: Maximum control over parsing behavior.

**Disadvantages**: More code to maintain, higher bug risk, reinventing existing functionality.

### Option 3: Regex Pattern with LazyLock (Selected)

**Description**: Use compiled regex patterns consistent with existing codebase.

**Advantages**: Consistent patterns, no new dependencies, fast execution.

**Disadvantages**: May miss edge cases like nested or escaped blocks.

## More Information

- **Date:** 2026-01-01
- **Source:** SPEC-2026-01-01-002: Prompt Variable Context-Aware Extraction

## Audit

### 2026-01-04

**Status:** Compliant

**Findings:**

| Finding | Files | Lines | Assessment |
|---------|-------|-------|------------|
| LazyLock regex patterns for fenced code blocks | `src/models/prompt.rs` | L83-L98 | compliant |

**Summary:** Code block detection uses compiled regexes via LazyLock.

**Action Required:** None
