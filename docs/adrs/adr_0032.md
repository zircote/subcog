---
title: "Use fastembed-rs for Embeddings"
description: "Use fastembed-rs with all-MiniLM-L6-v2 model for offline-first, deterministic semantic embeddings without API dependencies."
type: adr
category: ai-ml
tags:
  - embeddings
  - fastembed
  - onnx
  - semantic-search
  - minilm
status: published
created: 2026-01-02
updated: 2026-01-04
author: Claude (Architect)
project: subcog
technologies:
  - rust
  - fastembed
  - onnx
audience:
  - developers
  - architects
confidence: high
completeness: complete
---

# ADR-0032: Use fastembed-rs for Embeddings

## Status

Accepted

## Context

The current `FastEmbedEmbedder` uses a placeholder hash-based implementation that produces non-semantic vectors. This breaks all semantic search functionality.

Options considered:
1. **fastembed-rs** - Rust wrapper for ONNX-based embeddings
2. **Anthropic API** - Claude embeddings via API
3. **OpenAI API** - OpenAI embeddings via API
4. **candle** - Rust ML framework for local inference
5. **tokenizers + manual** - Build from scratch

## Decision

We will use **fastembed-rs** with the all-MiniLM-L6-v2 model.

## Consequences

### Positive

- Real semantic embeddings enable meaningful search
- No API keys or network required
- Deterministic results

### Negative

- Binary size increases by ~30MB (ONNX runtime + model)
- First embed has ~1-2s cold start (model loading)
- Model files need to be downloaded on first use

## Options Considered

| Option | Pros | Cons |
|--------|------|------|
| fastembed-rs | Offline, fast, well-maintained, easy API | Binary size (+~30MB) |
| Anthropic/OpenAI API | High quality | Network dependency, cost, latency |
| candle | Full control | Complex setup, maintenance burden |
| tokenizers | Minimal deps | Huge implementation effort |

## Decision Outcome

fastembed-rs provides the best balance of:
- **Offline-first**: No network calls, works in air-gapped environments
- **Performance**: ~30ms per embed after model load
- **Quality**: all-MiniLM-L6-v2 is proven for semantic search
- **Maintenance**: Active project, Rust-native

Mitigations for negative consequences:
- Lazy load model to preserve cold start
- Cache model in CI to avoid repeated downloads
- Consider model stripping for size optimization

## More Information

- **Date:** 2026-01-02
- **Source:** SPEC-2026-01-02: Memory System Critical Fixes
