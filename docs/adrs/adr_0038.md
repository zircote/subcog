---
title: "Vector Index Implementation - usearch"
description: "Use existing usearch HNSW implementation for vector similarity search rather than introducing new dependencies."
type: adr
category: search
tags:
  - vector-search
  - usearch
  - hnsw
  - cosine-similarity
status: published
created: 2026-01-02
updated: 2026-01-04
author: Claude (Architect)
project: subcog
technologies:
  - rust
  - usearch
audience:
  - developers
  - architects
confidence: high
completeness: complete
---

# ADR-0038: Vector Index Implementation - usearch

## Status

Accepted

## Context

Need a vector similarity search index for semantic search. The codebase already has `UsearchBackend` implemented but not connected.

## Decision Drivers

### Primary Decision Drivers

1. **Minimize New Dependencies**: Reuse existing implementation rather than adding new crates
2. **Performance**: Sub-10ms search latency for 10k vectors
3. **Persistence**: Index must survive restarts without full rebuild

### Secondary Decision Drivers

1. **Algorithmic Quality**: HNSW provides good recall/performance tradeoff
2. **Maintenance**: Less code to maintain by reusing existing work
3. **Testing**: Existing implementation already has test coverage

## Considered Options

### Option 1: usearch (Existing) - Selected

**Description**: Use existing HNSW index implementation with Rust bindings.

**Advantages**:
- No new implementation needed
- Battle-tested HNSW algorithm
- Fast search (<10ms for 10k vectors)
- Already implemented in codebase

**Disadvantages**:
- Single-node only (no distributed)
- Memory-mapped, needs disk space

### Option 2: hnswlib

**Description**: Original HNSW implementation.

**Advantages**:
- Well-known library

**Disadvantages**:
- Requires new FFI bindings
- Similar to usearch but less Rust-native

### Option 3: faiss

**Description**: Facebook's similarity search library.

**Advantages**:
- Feature-rich
- GPU support

**Disadvantages**:
- Heavy dependency
- Complex build
- Overkill for subcog scale

### Option 4: pgvector

**Description**: PostgreSQL extension for vector search.

**Advantages**:
- SQL integration
- Scalable

**Disadvantages**:
- Requires PostgreSQL
- Over-engineering for local use

### Option 5: milvus

**Description**: Distributed vector database.

**Advantages**:
- Scalable
- Feature-rich

**Disadvantages**:
- Requires separate service
- Way over-engineering

### Option 6: Brute Force

**Description**: Linear scan over all vectors.

**Advantages**:
- Simple
- 100% recall

**Disadvantages**:
- O(n) search time
- Slow for large collections

## Decision

We will use **usearch** (already implemented).

usearch is already implemented in the codebase at `src/storage/vector/usearch.rs` with both native and fallback modes. The implementation supports:
- HNSW graph structure
- Cosine similarity
- Namespace filtering
- Persistence to disk

No reason to change - just need to wire it up.

## Consequences

### Positive

- No new implementation needed
- Battle-tested HNSW algorithm
- Fast search (<10ms for 10k vectors)

### Negative

- Single-node only (no distributed)
- Memory-mapped, needs disk space

### Neutral

- PostgreSQL + pgvector available as scaling path
- Index can be rebuilt from persistence layer if needed

## Decision Outcome

Use existing usearch implementation rather than introducing new dependencies.

Mitigations:
- PostgreSQL + pgvector available for scaling
- Can migrate index without data loss (rebuild from persistence)

## More Information

- **Date:** 2026-01-02
- **Source:** SPEC-2026-01-02: Memory System Critical Fixes

## Audit

### 2026-01-04

**Status:** Compliant

**Findings:**

| Finding | Files | Lines | Assessment |
|---------|-------|-------|------------|
| usearch backend used for vector search | `src/storage/vector/usearch.rs` | L1-L88 | compliant |

**Summary:** usearch is the vector index implementation.

**Action Required:** None
