---
title: "SQLite for User-Scope Persistence"
description: "Use SQLite for user-scope persistence outside git repositories, leveraging existing rusqlite dependency for ACID-compliant storage."
type: adr
category: storage
tags:
  - sqlite
  - persistence
  - user-scope
  - acid
status: published
created: 2026-01-02
updated: 2026-01-04
author: Claude (Architect)
project: subcog
technologies:
  - sqlite
  - rusqlite
audience:
  - developers
  - architects
confidence: high
completeness: complete
---

# ADR-0040: SQLite for User-Scope Persistence

## Status

Accepted

## Context

When operating outside a git repository, we need an alternative persistence layer for user-scoped memories.

## Decision Drivers

### Primary Decision Drivers

1. **Dependency Reuse**: rusqlite is already a dependency; avoid adding new crates
2. **ACID Compliance**: Atomic operations prevent data loss on crashes
3. **Query Support**: Need filtering by namespace and content search

### Secondary Decision Drivers

1. **Backup Simplicity**: Single file is easy to backup and migrate
2. **Familiarity**: Patterns from index implementation can be reused
3. **Performance**: SQLite is fast for single-user workloads

## Considered Options

### Option 1: SQLite Database (Selected)

**Description**: Use SQLite for user-scope persistence.

**Advantages**:
- No new dependencies (`rusqlite` already used for index layer)
- Familiar patterns from index implementation
- Atomic operations prevent data loss
- ACID transactions prevent data corruption on crash
- Single file for easy backup (`memories.db`)
- Query support for filtering by namespace, searching content

**Disadvantages**:
- Not human-readable like JSON/YAML
- Requires schema migrations for future changes

### Option 2: JSON Files in User Directory

**Description**: Store memories as individual JSON files.

**Advantages**:
- Human-readable
- Easy to edit manually

**Disadvantages**:
- No ACID guarantees
- Harder to query
- File-per-memory creates clutter
- No atomic operations

### Option 3: TOML/YAML Files

**Description**: Use TOML or YAML for configuration-style storage.

**Advantages**:
- Human-readable
- Easy to edit

**Disadvantages**:
- Same issues as JSON
- No ACID
- No query support

### Option 4: Memory Only (No Persistence)

**Description**: Keep memories in-memory only for user scope.

**Advantages**:
- Simplest implementation

**Disadvantages**:
- Data lost on restart
- Unacceptable for memories

## Decision

We will use **SQLite** for user-scope persistence.

## Consequences

### Positive

- No new dependencies (`rusqlite` already used for index layer)
- Familiar patterns from index implementation
- Atomic operations prevent data loss
- ACID transactions prevent data corruption on crash
- Single file for easy backup (`memories.db`)
- Query support for filtering by namespace, searching content

### Negative

- Not human-readable like JSON/YAML
- Requires schema migrations for future changes

### Neutral

- SQLite tooling (DB Browser) available for inspection if needed
- Migration infrastructure may be useful for future schema evolution

## Decision Outcome

SQLite provides the best balance of reliability, performance, and development efficiency given it's already a dependency.

## More Information

- **Date:** 2026-01-02
- **Source:** SPEC-2026-01-02: User-Scope Storage Fallback

## Audit

### 2026-01-04

**Status:** Compliant

**Findings:**

| Finding | Files | Lines | Assessment |
|---------|-------|-------|------------|
| ServiceContainer::for_user builds SQLite backends for user scope | `src/services/mod.rs` | L279-L337 | compliant |

**Summary:** User-scoped storage initializes SQLite backends in the user data directory.

**Action Required:** None
