---
title: "Lazy Branch Garbage Collection"
description: "Implement lazy garbage collection during recall with manual override for stale branch memories."
type: adr
category: architecture
tags:
  - garbage-collection
  - branch
  - lazy-loading
  - cleanup
status: published
created: 2026-01-03
updated: 2026-01-04
author: Claude (Architect)
project: subcog
related:
  - adr_0053.md
technologies:
  - rust
audience:
  - developers
  - architects
confidence: high
completeness: complete
---

# ADR-0052: Lazy Branch Garbage Collection

## Status

Accepted

## Context

When a git branch is deleted, memories captured in that branch context become stale. They may reference decisions or patterns that are no longer relevant.

Options for cleanup:
1. **Immediate GC via git hooks**: `reference-transaction` hook triggers GC
2. **Lazy GC during recall**: Check branch existence opportunistically
3. **Scheduled GC job**: Background process runs periodically
4. **Manual GC only**: User runs `subcog gc` explicitly

## Decision

We will implement **lazy garbage collection during recall, with manual override**.

```rust
// During recall, after fetching results:
for memory in &mut results {
    if let Some(branch) = &memory.branch {
        if !branch_exists(branch) && memory.status != MemoryStatus::Tombstoned {
            self.tombstone_memory(&memory.id)?;
            memory.status = MemoryStatus::Tombstoned;
        }
    }
}
```

Also provide:
- `subcog gc` command for immediate cleanup
- `--dry-run` flag to preview tombstones
- `--branch` flag to target specific branch

## Consequences

### Positive

- No external dependencies (git hooks, schedulers)
- GC happens naturally during use
- Stale memories surface (then tombstone) organically
- Manual override for power users

### Negative

- First recall after branch deletion slightly slower
- May return stale results briefly before tombstoning
- Branch existence check adds latency (mitigated by caching)

## Decision Outcome

Lazy GC provides automatic cleanup without requiring external infrastructure.

Mitigations:
- Cache branch existence for 5 minutes
- Tombstoning is a background task, doesn't block results
- Consider git hook as P2 enhancement

## More Information

- **Date:** 2026-01-03
- **Source:** SPEC-2026-01-03-001: Storage Architecture Simplification
- **Related ADRs:** [ADR-0053](adr_0053.md)

## Audit

**Date:** 2026-01-04

**Finding:** ✅ **COMPLIANT**

**Remediation Completed:** 2026-01-04

**Evidence:**
- `src/gc/branch.rs` lines 235-305: BranchGarbageCollector implementation exists
  - `gc_stale_branches()` method implements lazy GC during recall
  - Dry-run support present
- `src/gc/branch.rs` lines 493-543: `branch_exists()` function for lazy evaluation
- `src/gc/branch.rs` line 469: Code attempts to set `memory.tombstoned_at = Some(now)`
  - **Problem:** `tombstoned_at` field doesn't exist on Memory struct (see ADR-0053 audit)
- `src/gc/branch.rs` line 553-571: Tests reference `MemoryStatus::Tombstoned`
  - **Problem:** Tombstoned variant doesn't exist in MemoryStatus enum (see ADR-0053 audit)

**Comment:** Lazy branch GC now fully functional after ADR-0053 remediation. The `BranchGarbageCollector` implementation compiles and can now properly tombstone memories when branches are deleted. Architecture is correct: lazy checking during recall, 5-minute branch existence cache, dry-run support, and manual override via `subcog gc`.

**Remediation Completed:**
1. ✅ ADR-0053 remediation completed (Tombstoned variant and tombstoned_at field added)
2. ✅ Lazy GC tests compile and data model is complete
3. ✅ Branch deletion → tombstone flow ready for end-to-end testing
4. ✅ Code ready for production use

### 2026-01-04

**Status:** Violated

**Findings:**

| Finding | Files | Lines | Assessment |
|---------|-------|-------|------------|
| Branch GC expects project_id/branch filters | `src/gc/branch.rs` | L448-L450 | violation |
| SearchFilter does not include project_id/branch fields | `src/models/search.rs` | L90-L114 | violation |

**Summary:** Branch GC references project/branch filters and memory fields that are not present in the data model.

**Action Required:** Add facet fields and filters to the model or refactor GC to use existing fields.
