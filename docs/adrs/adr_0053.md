---
title: "Tombstone Pattern for Soft Deletes"
description: "Use tombstone status for soft deletes with configurable visibility to prevent accidental data loss."
type: adr
category: architecture
tags:
  - soft-delete
  - tombstone
  - data-safety
  - cleanup
status: published
created: 2026-01-03
updated: 2026-01-04
author: Claude (Architect)
project: subcog
related:
  - adr_0052.md
technologies:
  - rust
audience:
  - developers
  - architects
confidence: high
completeness: complete
---

# ADR-0053: Tombstone Pattern for Soft Deletes

## Status

Accepted

## Context

When memories become stale (branch deleted, manual cleanup), we need to remove them from active results.

Options considered:
1. **Hard delete**: Remove rows permanently
2. **Soft delete (tombstone)**: Mark as deleted, filter by default
3. **Archive**: Move to separate table

## Decision

We will use **tombstone status for soft deletes** with configurable visibility.

```rust
pub enum MemoryStatus {
    Active,
    Tombstoned,
}
```

Behavior:
- Tombstoned memories are **hidden by default** in recall
- `--include-tombstoned` flag shows them
- Tombstones are **never auto-purged** (data safety)
- Manual purge via `subcog gc --purge --older-than=30d`

## Consequences

### Positive

- No accidental data loss
- Archaeology possible (find old decisions)
- Simple implementation (just a status flag)
- Consistent with existing `MemoryStatus` enum

### Negative

- Storage never automatically reclaimed
- Index bloat over time (mitigated by purge command)

## Alternatives Considered

- **Hard delete**: Risk of accidental data loss, no recovery
- **Archive table**: More complex, similar benefits

## Decision Outcome

Tombstone pattern provides data safety while keeping implementation simple.

Mitigations:
- Document purge workflow
- Consider automatic tombstone indexing for filtered queries
- Add `tombstoned_at` timestamp for retention policies

## More Information

- **Date:** 2026-01-03
- **Source:** SPEC-2026-01-03-001: Storage Architecture Simplification
- **Related ADRs:** [ADR-0052](adr_0052.md)

## Audit

**Date:** 2026-01-04

**Finding:** ‚ùå **CRITICAL - NON-COMPLIANT**

**Evidence:**
- `src/models/domain.rs` lines 260-295: MemoryStatus enum contains only: Active, Archived, Superseded, Pending, Deleted
  - **Missing:** `Tombstoned` variant specified in this ADR
- `src/models/memory.rs` lines 43-66: Memory struct fields do not include `tombstoned_at`
  - **Missing:** `pub tombstoned_at: Option<DateTime<Utc>>` field
- `src/gc/branch.rs` lines 469, 553-571: Code references both `MemoryStatus::Tombstoned` and `memory.tombstoned_at`
  - **Problem:** References non-existent model fields, will cause compilation errors

**Comment:** This is a **critical data model gap**. The tombstone pattern is specified in the ADR and referenced throughout the GC logic, but the actual model definitions were never updated to include the required enum variant and timestamp field. This blocks ADR-0052 (Lazy Branch GC) which depends on tombstoning.

**Remediation Required:**
1. Add `Tombstoned` variant to MemoryStatus enum in `src/models/domain.rs`
2. Add `pub tombstoned_at: Option<DateTime<Utc>>` field to Memory struct in `src/models/memory.rs`
3. Create SQLite migration to add `tombstoned_at TIMESTAMP NULL` column to memories table
4. Update serde serialization to handle the new field
5. Run full test suite to verify lazy GC works correctly
