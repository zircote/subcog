---
title: "Tombstone Pattern for Soft Deletes"
description: "Use tombstone status for soft deletes with configurable visibility to prevent accidental data loss."
type: adr
category: architecture
tags:
  - soft-delete
  - tombstone
  - data-safety
  - cleanup
status: published
created: 2026-01-03
updated: 2026-01-04
author: Claude (Architect)
project: subcog
related:
  - adr_0052.md
technologies:
  - rust
audience:
  - developers
  - architects
confidence: high
completeness: complete
---

# ADR-0053: Tombstone Pattern for Soft Deletes

## Status

Accepted

## Context

When memories become stale (branch deleted, manual cleanup), we need to remove them from active results.

Options considered:
1. **Hard delete**: Remove rows permanently
2. **Soft delete (tombstone)**: Mark as deleted, filter by default
3. **Archive**: Move to separate table

## Decision Drivers

### Primary Decision Drivers

1. **Data Safety**: Accidental data loss is unacceptable
2. **Recoverability**: Users should be able to undo deletions
3. **Auditability**: Historical record of deletions is valuable for debugging

### Secondary Decision Drivers

1. **Implementation Simplicity**: Status flag is simpler than archive tables
2. **Query Efficiency**: Filtering by status is efficient with proper indexing

## Considered Options

### Option 1: Tombstone Status (Selected)

**Description**: Add `Tombstoned` status to MemoryStatus enum, filter by default in queries.

**Advantages**:
- No accidental data loss
- Archaeology possible (find old decisions)
- Simple implementation (just a status flag)
- Consistent with existing `MemoryStatus` enum

**Disadvantages**:
- Storage never automatically reclaimed
- Index bloat over time (mitigated by purge command)

### Option 2: Hard Delete

**Description**: Permanently remove rows from database.

**Advantages**:
- Storage reclaimed immediately
- No index bloat

**Disadvantages**:
- Risk of accidental data loss
- No recovery possible
- No audit trail

### Option 3: Archive Table

**Description**: Move deleted memories to separate archive table.

**Advantages**:
- Main table stays clean
- Archive can have different retention policy

**Disadvantages**:
- More complex implementation
- Two tables to query for full history
- Migration complexity

## Decision

We will use **tombstone status for soft deletes** with configurable visibility.

```rust
pub enum MemoryStatus {
    Active,
    Tombstoned,
}
```

Behavior:
- Tombstoned memories are **hidden by default** in recall
- `--include-tombstoned` flag shows them
- Tombstones are **never auto-purged** (data safety)
- Manual purge via `subcog gc --purge --older-than=30d`

## Consequences

### Positive

- No accidental data loss
- Archaeology possible (find old decisions)
- Simple implementation (just a status flag)
- Consistent with existing `MemoryStatus` enum

### Negative

- Storage never automatically reclaimed
- Index bloat over time (mitigated by purge command)

### Neutral

- Mitigations available: Document purge workflow; consider automatic tombstone indexing for filtered queries; add `tombstoned_at` timestamp for retention policies

## More Information

- **Date:** 2026-01-03
- **Source:** SPEC-2026-01-03-001: Storage Architecture Simplification
- **Related ADRs:** [ADR-0052](adr_0052.md)

## Audit

**Date:** 2026-01-04

**Finding:** Compliant

**Remediation Completed:** 2026-01-04

**Evidence:**
- `src/models/domain.rs` lines 260-295: MemoryStatus enum contains only: Active, Archived, Superseded, Pending, Deleted
  - **Missing:** `Tombstoned` variant specified in this ADR
- `src/models/memory.rs` lines 43-66: Memory struct fields do not include `tombstoned_at`
  - **Missing:** `pub tombstoned_at: Option<DateTime<Utc>>` field
- `src/gc/branch.rs` lines 469, 553-571: Code references both `MemoryStatus::Tombstoned` and `memory.tombstoned_at`
  - **Problem:** References non-existent model fields, will cause compilation errors

**Comment:** This is a **critical data model gap**. The tombstone pattern is specified in the ADR and referenced throughout the GC logic, but the actual model definitions were never updated to include the required enum variant and timestamp field. This blocks ADR-0052 (Lazy Branch GC) which depends on tombstoning.

**Remediation Completed:**
1. Added `Tombstoned` variant to MemoryStatus enum (`src/models/domain.rs:275`)
2. Added `tombstoned_at: Option<u64>` field to Memory struct (`src/models/memory.rs:61`)
3. Created SQLite migration inline (`src/storage/index/sqlite.rs:251`)
4. Created PostgreSQL migration v4 (`src/storage/persistence/postgresql.rs:56-61`)
5. Updated all Memory initializers (30+ locations)
6. Implemented TombstoneService (`src/services/tombstone.rs`)
7. Added tombstone filtering to SearchFilter
8. All tests passing, `make ci` clean

### 2026-01-04

**Status:** Compliant

**Findings:**

| Finding | Files | Lines | Assessment |
|---------|-------|-------|------------|
| MemoryStatus includes Tombstoned | `src/models/domain.rs` | L260-L288 | compliant |
| SQLite schema stores tombstoned_at | `src/storage/index/sqlite.rs` | L251-L252 | compliant |
| Tombstoned memories are excluded by default | `src/storage/index/sqlite.rs` | L428-L430 | compliant |

**Summary:** Tombstone status and timestamps are stored and filtered as specified.

**Action Required:** None
